<h1 id="mercury-re-tutorial">Mercury-RE Tutorial</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ol type="1">
<li><a href="#introduction">Introduction</a></li>
<li><a href="#installation">Installation</a></li>
<li><a href="#getting-started">Getting Started</a></li>
<li><a href="#pattern-matching-operations">Pattern Matching
Operations</a></li>
<li><a href="#working-with-match-objects">Working with Match
Objects</a></li>
<li><a href="#capture-groups">Capture Groups</a></li>
<li><a href="#compilation-flags">Compilation Flags</a></li>
<li><a href="#finding-multiple-matches">Finding Multiple
Matches</a></li>
<li><a href="#string-substitution">String Substitution</a></li>
<li><a href="#string-splitting">String Splitting</a></li>
<li><a href="#special-characters-and-escaping">Special Characters and
Escaping</a></li>
<li><a href="#error-handling">Error Handling</a></li>
<li><a href="#common-patterns-cookbook">Common Patterns
Cookbook</a></li>
<li><a href="#performance-tips">Performance Tips</a></li>
<li><a href="#complete-examples">Complete Examples</a></li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>Mercury-RE is a regular expression library for the Mercury
programming language that provides Python re module functionality using
the PCRE2 (Perl Compatible Regular Expressions 2) library. It offers a
familiar API for Mercury developers who need powerful pattern matching
capabilities.</p>
<h3 id="features">Features</h3>
<ul>
<li>Full PCRE2 regex support</li>
<li>Python-style named groups</li>
<li>Compilation flags (case-insensitive, multiline, etc.)</li>
<li>Find all matches functionality</li>
<li>String substitution and splitting</li>
<li>Proper Mercury type safety</li>
</ul>
<h2 id="installation">Installation</h2>
<h3 id="prerequisites">Prerequisites</h3>
<ol type="1">
<li><p>Mercury compiler installed and in PATH</p></li>
<li><p>PCRE2 library installed:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># macOS</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">brew</span> install pcre2</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Ubuntu/Debian</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> apt-get install libpcre2-dev</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Fedora/RHEL</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> dnf install pcre2-devel</span></code></pre></div></li>
</ol>
<h3 id="building-the-library">Building the Library</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> mercury-re</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">make</span> install</span></code></pre></div>
<h3 id="using-in-your-project">Using in Your Project</h3>
<p>Add to your Mercury.options file:</p>
<pre><code>EXTRA_LIBRARIES = regex
EXTRA_LIB_DIRS = /path/to/mercury-re/src
MCFLAGS = --clang-flags &quot;`pkg-config --cflags libpcre2-8`&quot; \
          --ld-flags &quot;`pkg-config --libs libpcre2-8`&quot;</code></pre>
<h2 id="getting-started">Getting Started</h2>
<h3 id="basic-pattern-matching">Basic Pattern Matching</h3>
<pre class="mercury"><code>:- module hello_regex.
:- interface.
:- import_module io.
:- pred main(io::di, io::uo) is det.

:- implementation.
:- import_module regex.
:- import_module maybe.
:- import_module string.

main(!IO) :-
    % Simple pattern search
    Text = &quot;Hello, World! Welcome to Mercury.&quot;,
    Pattern = &quot;World&quot;,
    
    regex.search(Pattern, Text, Result),
    (
        Result = yes(Match),
        Match = match(_, _, Start, End, _, _),
        io.format(&quot;Found &#39;%s&#39; at positions %d-%d\n&quot;, 
                  [s(Pattern), i(Start), i(End)], !IO)
    ;
        Result = no,
        io.write_string(&quot;Pattern not found\n&quot;, !IO)
    ).</code></pre>
<h3 id="understanding-mercury-string-escaping">Understanding Mercury
String Escaping</h3>
<p>Mercury requires backslashes in strings to be escaped. Common
patterns: - <code>\d</code> becomes <code>"\\d"</code> (digit) -
<code>\w</code> becomes <code>"\\w"</code> (word character) -
<code>\s</code> becomes <code>"\\s"</code> (whitespace) -
<code>\\</code> becomes <code>"\\\\"</code> (literal backslash)</p>
<h2 id="pattern-matching-operations">Pattern Matching Operations</h2>
<h3 id="search3---find-first-match-anywhere">search/3 - Find First Match
Anywhere</h3>
<pre class="mercury"><code>% Find the first number in a string
regex.search(&quot;\\d+&quot;, &quot;The answer is 42&quot;, Result),
% Finds &quot;42&quot;</code></pre>
<h3 id="match3---match-at-beginning-only">match/3 - Match at Beginning
Only</h3>
<pre class="mercury"><code>% Check if string starts with pattern
regex.match(&quot;Hello&quot;, &quot;Hello, World!&quot;, Result1),  % succeeds
regex.match(&quot;World&quot;, &quot;Hello, World!&quot;, Result2),  % fails</code></pre>
<h3 id="fullmatch3---match-entire-string">fullmatch/3 - Match Entire
String</h3>
<pre class="mercury"><code>% Validate entire string against pattern
regex.fullmatch(&quot;\\d{3}-\\d{3}-\\d{4}&quot;, &quot;555-123-4567&quot;, Result1),  % succeeds
regex.fullmatch(&quot;\\d{3}-\\d{3}-\\d{4}&quot;, &quot;Call 555-123-4567&quot;, Result2),  % fails</code></pre>
<h2 id="working-with-match-objects">Working with Match Objects</h2>
<p>The <code>match</code> type contains:</p>
<pre class="mercury"><code>:- type match
    ---&gt;    match(
                string      :: string,      % Original string
                pattern     :: string,      % Pattern used
                start_pos   :: int,         % Start position of match
                end_pos     :: int,         % End position of match
                groups      :: list(maybe(string)),  % Captured groups
                named_groups :: map(string, maybe(string))  % Named groups
            ).</code></pre>
<h3 id="extracting-match-information">Extracting Match Information</h3>
<pre class="mercury"><code>regex.search(&quot;(\\w+)@(\\w+\\.\\w+)&quot;, &quot;Contact: john@example.com&quot;, Result),
(
    Result = yes(Match),
    Match = match(_, _, Start, End, _, _),
    
    % Get the matched substring
    string.between(&quot;Contact: john@example.com&quot;, Start, End, Email),
    io.format(&quot;Email: %s\n&quot;, [s(Email)], !IO),
    
    % Get match positions
    regex.span(Match, 0, Span),  % Span = yes({Start, End})
    regex.start(Match, 0, StartPos),  % StartPos = yes(Start)
    regex.end(Match, 0, EndPos)       % EndPos = yes(End)
).</code></pre>
<h2 id="capture-groups">Capture Groups</h2>
<h3 id="numbered-groups">Numbered Groups</h3>
<p>Groups are numbered starting from 1 (group 0 is the entire
match):</p>
<pre class="mercury"><code>% Parse a date
DatePattern = &quot;(\\d{4})-(\\d{2})-(\\d{2})&quot;,
regex.search(DatePattern, &quot;Today is 2024-01-15&quot;, Result),
(
    Result = yes(Match),
    
    % Access individual groups
    regex.group(Match, 0, FullMatch),   % yes(&quot;2024-01-15&quot;)
    regex.group(Match, 1, Year),        % yes(&quot;2024&quot;)
    regex.group(Match, 2, Month),       % yes(&quot;01&quot;)
    regex.group(Match, 3, Day),         % yes(&quot;15&quot;)
    
    % Get all groups at once (excludes group 0)
    regex.groups(Match, AllGroups),     % [yes(&quot;2024&quot;), yes(&quot;01&quot;), yes(&quot;15&quot;)]
    
    io.format(&quot;Date: %s/%s/%s\n&quot;, 
              [s(maybe_to_string(Month)), 
               s(maybe_to_string(Day)), 
               s(maybe_to_string(Year))], !IO)
).

:- func maybe_to_string(maybe(string)) = string.
maybe_to_string(yes(S)) = S.
maybe_to_string(no) = &quot;&quot;.</code></pre>
<h3 id="named-groups">Named Groups</h3>
<p>Use Python-style <code>(?P&lt;name&gt;...)</code> syntax:</p>
<pre class="mercury"><code>% Parse a log entry with named groups
LogPattern = &quot;(?P&lt;timestamp&gt;\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}) &quot; ++
             &quot;\\[(?P&lt;level&gt;\\w+)\\] (?P&lt;message&gt;.*)&quot;,
             
LogLine = &quot;2024-01-15 10:30:45 [ERROR] Connection failed&quot;,

regex.search(LogPattern, LogLine, Result),
(
    Result = yes(Match),
    
    % Access by name
    regex.group_by_name(Match, &quot;timestamp&quot;, Timestamp),
    regex.group_by_name(Match, &quot;level&quot;, Level),
    regex.group_by_name(Match, &quot;message&quot;, Message),
    
    % Get all named group names
    regex.named_group_names(Match, Names),
    % Names = [&quot;level&quot;, &quot;message&quot;, &quot;timestamp&quot;]
    
    (
        Level = yes(&quot;ERROR&quot;),
        io.write_string(&quot;ERROR detected!\n&quot;, !IO)
    ;
        Level = yes(&quot;WARNING&quot;),
        io.write_string(&quot;Warning logged\n&quot;, !IO)
    ;
        true
    )
).</code></pre>
<h3 id="optional-groups">Optional Groups</h3>
<p>Groups can be optional using <code>?</code>:</p>
<pre class="mercury"><code>% Phone number with optional area code
PhonePattern = &quot;(\\d{3}-)?(\\d{3}-\\d{4})&quot;,
regex.search(PhonePattern, &quot;555-1234&quot;, Result1),
% Group 1 = no, Group 2 = yes(&quot;555-1234&quot;)

regex.search(PhonePattern, &quot;800-555-1234&quot;, Result2),
% Group 1 = yes(&quot;800-&quot;), Group 2 = yes(&quot;555-1234&quot;)</code></pre>
<h2 id="compilation-flags">Compilation Flags</h2>
<h3 id="available-flags">Available Flags</h3>
<ul>
<li><code>ignorecase</code> - Case-insensitive matching</li>
<li><code>multiline</code> - ^ and $ match line boundaries</li>
<li><code>dotall</code> - . matches newlines</li>
<li><code>verbose</code> - Ignore whitespace and comments in
pattern</li>
<li><code>ascii</code> - ASCII-only matching</li>
<li><code>unicode</code> - Unicode matching (default)</li>
</ul>
<h3 id="using-flags">Using Flags</h3>
<pre class="mercury"><code>% Case-insensitive search
regex.compile(&quot;hello&quot;, [ignorecase], CompiledResult),
(
    CompiledResult = ok(CaseInsensitiveRegex),
    regex.search_compiled(CaseInsensitiveRegex, &quot;HELLO WORLD&quot;, Match),
    % This will find &quot;HELLO&quot;
    
    % Use multiple flags
    regex.compile(&quot;^world&quot;, [ignorecase, multiline], MultilineResult),
    (
        MultilineResult = ok(MultilineRegex),
        regex.search_compiled(MultilineRegex, &quot;Hello\nWORLD&quot;, Match2)
        % Matches &quot;WORLD&quot; at start of second line
    )
).

% Direct use with flags
regex.search_with_flags(&quot;HELLO&quot;, &quot;hello world&quot;, [ignorecase], Result).</code></pre>
<h2 id="finding-multiple-matches">Finding Multiple Matches</h2>
<h3 id="findall3---get-all-matching-strings">findall/3 - Get All
Matching Strings</h3>
<pre class="mercury"><code>% Extract all email addresses
EmailPattern = &quot;\\b[\\w._%+-]+@[\\w.-]+\\.[A-Z|a-z]{2,}\\b&quot;,
Text = &quot;Contact alice@example.com or bob@test.org for details&quot;,

regex.findall(EmailPattern, Text, Emails),
% Emails = [&quot;alice@example.com&quot;, &quot;bob@test.org&quot;]

% Extract all numbers
regex.findall(&quot;\\d+&quot;, &quot;Room 101, Floor 3, Building 42&quot;, Numbers),
% Numbers = [&quot;101&quot;, &quot;3&quot;, &quot;42&quot;]</code></pre>
<h3 id="finditer3---get-all-match-objects">finditer/3 - Get All Match
Objects</h3>
<pre class="mercury"><code>% Get detailed information about all matches
regex.finditer(&quot;\\w+&quot;, &quot;Hello World&quot;, Matches),
list.foldl(process_match, Matches, !IO).

:- pred process_match(match::in, io::di, io::uo) is det.
process_match(Match, !IO) :-
    Match = match(_, _, Start, End, _, _),
    string.between(&quot;Hello World&quot;, Start, End, Word),
    io.format(&quot;Found &#39;%s&#39; at %d-%d\n&quot;, [s(Word), i(Start), i(End)], !IO).
% Output:
% Found &#39;Hello&#39; at 0-5
% Found &#39;World&#39; at 6-11</code></pre>
<h2 id="string-substitution">String Substitution</h2>
<h3 id="sub4---replace-all-occurrences">sub/4 - Replace All
Occurrences</h3>
<pre class="mercury"><code>% Simple replacement
regex.sub(&quot;cat&quot;, &quot;dog&quot;, &quot;The cat chased the cat&quot;, Result),
% Result = &quot;The dog chased the dog&quot;

% Using backreferences
regex.sub(&quot;(\\w+)@(\\w+)&quot;, &quot;\\2.\\1&quot;, &quot;user@domain&quot;, Result2),
% Result2 = &quot;domain.user&quot;

% Complex replacement
regex.sub(&quot;\\b(\\w)(\\w+)&quot;, &quot;\\U\\1\\L\\2&quot;, &quot;hello world&quot;, Result3),
% Result3 = &quot;Hello World&quot; (capitalize words)</code></pre>
<h3 id="sub5---replace-with-limit">sub/5 - Replace with Limit</h3>
<pre class="mercury"><code>% Replace only first N occurrences
regex.sub(&quot;a&quot;, &quot;A&quot;, &quot;banana&quot;, 2, Result),
% Result = &quot;bAnAna&quot; (only first 2 &#39;a&#39;s replaced)

% Count = 0 means replace all
regex.sub(&quot;e&quot;, &quot;E&quot;, &quot;elephant&quot;, 0, Result2),
% Result2 = &quot;ElEphant&quot;</code></pre>
<h3 id="subn6---replace-and-count">subn/6 - Replace and Count</h3>
<pre class="mercury"><code>% Get replacement count
regex.subn(&quot;\\d+&quot;, &quot;[NUM]&quot;, &quot;Room 101 on Floor 3&quot;, 0, Result, Count),
% Result = &quot;Room [NUM] on Floor [NUM]&quot;
% Count = 2</code></pre>
<h2 id="string-splitting">String Splitting</h2>
<h3 id="split3---split-with-no-limit">split/3 - Split with No Limit</h3>
<pre class="mercury"><code>% Split by whitespace
regex.split(&quot;\\s+&quot;, &quot;one   two     three&quot;, Parts),
% Parts = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]

% Split by punctuation
regex.split(&quot;[,;]&quot;, &quot;apple,banana;orange,grape&quot;, Fruits),
% Fruits = [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;grape&quot;]</code></pre>
<h3 id="split4---split-with-limit">split/4 - Split with Limit</h3>
<pre class="mercury"><code>% Limit number of splits
regex.split(&quot;,&quot;, &quot;a,b,c,d,e&quot;, 2, Parts),
% Parts = [&quot;a&quot;, &quot;b&quot;, &quot;c,d,e&quot;] (only 2 splits performed)

% Split lines with limit
regex.split(&quot;\\n&quot;, &quot;line1\nline2\nline3\nline4&quot;, 2, FirstTwoLines),
% FirstTwoLines = [&quot;line1&quot;, &quot;line2&quot;, &quot;line3\nline4&quot;]</code></pre>
<h2 id="special-characters-and-escaping">Special Characters and
Escaping</h2>
<h3 id="escape2---escape-special-characters">escape/2 - Escape Special
Characters</h3>
<pre class="mercury"><code>% Escape user input for safe pattern use
UserInput = &quot;What&#39;s the cost? $5.99!&quot;,
regex.escape(UserInput, SafePattern),
% SafePattern = &quot;What&#39;s the cost\\? \\$5\\.99!&quot;

% Use escaped string in search
regex.search(SafePattern, &quot;The price is: What&#39;s the cost? $5.99!&quot;, Found).</code></pre>
<h3 id="common-special-characters">Common Special Characters</h3>
<ul>
<li><code>.</code> - Any character (except newline unless dotall
flag)</li>
<li><code>*</code> - Zero or more</li>
<li><code>+</code> - One or more</li>
<li><code>?</code> - Zero or one</li>
<li><code>^</code> - Start of string/line</li>
<li><code>$</code> - End of string/line</li>
<li><code>[]</code> - Character class</li>
<li><code>()</code> - Group</li>
<li><code>{}</code> - Quantifier</li>
<li><code>|</code> - Alternation</li>
<li><code>\</code> - Escape character</li>
</ul>
<h2 id="error-handling">Error Handling</h2>
<h3 id="compilation-errors">Compilation Errors</h3>
<pre class="mercury"><code>:- pred safe_regex_search(string::in, string::in, maybe(match)::out, 
                         string::out, io::di, io::uo) is det.
safe_regex_search(Pattern, Text, Result, ErrorMsg, !IO) :-
    regex.compile(Pattern, CompileResult),
    (
        CompileResult = ok(Regex),
        regex.search_compiled(Regex, Text, Result),
        ErrorMsg = &quot;&quot;
    ;
        CompileResult = error(compile_error(Msg)),
        Result = no,
        ErrorMsg = Msg,
        io.format(&quot;Regex compilation error: %s\n&quot;, [s(Msg)], !IO)
    ).

% Example usage
safe_regex_search(&quot;[invalid&quot;, &quot;text&quot;, Result, Error, !IO).
% Outputs: Regex compilation error: missing terminating ] for character class</code></pre>
<h3 id="pattern-validation">Pattern Validation</h3>
<pre class="mercury"><code>:- pred is_valid_pattern(string::in) is semidet.
is_valid_pattern(Pattern) :-
    regex.compile(Pattern, ok(_)).

% Use in input validation
( is_valid_pattern(UserPattern) -&gt;
    process_with_pattern(UserPattern, !IO)
;
    io.write_string(&quot;Invalid regex pattern\n&quot;, !IO)
).</code></pre>
<h2 id="common-patterns-cookbook">Common Patterns Cookbook</h2>
<h3 id="email-validation">Email Validation</h3>
<pre class="mercury"><code>email_pattern = &quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot;.

:- pred is_valid_email(string::in) is semidet.
is_valid_email(Email) :-
    regex.fullmatch(email_pattern, Email, yes(_)).</code></pre>
<h3 id="url-extraction">URL Extraction</h3>
<pre class="mercury"><code>url_pattern = &quot;https?://[^\\s]+&quot;.

:- pred extract_urls(string::in, list(string)::out) is det.
extract_urls(Text, URLs) :-
    regex.findall(url_pattern, Text, URLs).</code></pre>
<h3 id="phone-number-validation">Phone Number Validation</h3>
<pre class="mercury"><code>% US phone number formats
us_phone_pattern = &quot;^\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$&quot;.

:- pred normalize_phone(string::in, string::out) is semidet.
normalize_phone(Phone, Normalized) :-
    regex.search(us_phone_pattern, Phone, yes(Match)),
    regex.group(Match, 1, yes(Area)),
    regex.group(Match, 2, yes(Prefix)),
    regex.group(Match, 3, yes(Number)),
    Normalized = string.format(&quot;(%s) %s-%s&quot;, [s(Area), s(Prefix), s(Number)]).</code></pre>
<h3 id="ip-address-validation">IP Address Validation</h3>
<pre class="mercury"><code>ipv4_pattern = &quot;^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}&quot; ++
               &quot;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$&quot;.

:- pred is_valid_ipv4(string::in) is semidet.
is_valid_ipv4(IP) :-
    regex.fullmatch(ipv4_pattern, IP, yes(_)).</code></pre>
<h3 id="html-tag-removal">HTML Tag Removal</h3>
<pre class="mercury"><code>:- pred strip_html_tags(string::in, string::out) is det.
strip_html_tags(HTML, Text) :-
    regex.sub(&quot;&lt;[^&gt;]+&gt;&quot;, &quot;&quot;, HTML, Text).</code></pre>
<h3 id="csv-parsing">CSV Parsing</h3>
<pre class="mercury"><code>:- pred parse_csv_line(string::in, list(string)::out) is det.
parse_csv_line(Line, Fields) :-
    % Handle quoted fields with commas
    CSVPattern = &quot;(?:^|,)(?:\&quot;([^\&quot;]*)\&quot;|([^,]*))&quot;,
    regex.finditer(CSVPattern, Line, Matches),
    list.map(extract_csv_field, Matches, Fields).

:- pred extract_csv_field(match::in, string::out) is det.
extract_csv_field(Match, Field) :-
    ( regex.group(Match, 1, yes(Quoted)) -&gt;
        Field = Quoted
    ; regex.group(Match, 2, yes(Unquoted)) -&gt;
        Field = Unquoted
    ;
        Field = &quot;&quot;
    ).</code></pre>
<h2 id="performance-tips">Performance Tips</h2>
<h3 id="compile-once-use-many-times">1. Compile Once, Use Many
Times</h3>
<pre class="mercury"><code>:- type processor
    ---&gt;    processor(
                log_regex    :: regex,
                error_regex  :: regex,
                warn_regex   :: regex
            ).

:- pred init_processor(processor::out, io::di, io::uo) is det.
init_processor(Processor, !IO) :-
    regex.compile(&quot;\\[(\\d{4}-\\d{2}-\\d{2})\\] (\\w+): (.*)&quot;, LogRes),
    regex.compile(&quot;ERROR|FATAL&quot;, [ignorecase], ErrorRes),
    regex.compile(&quot;WARN|WARNING&quot;, [ignorecase], WarnRes),
    (
        LogRes = ok(LogRegex),
        ErrorRes = ok(ErrorRegex),
        WarnRes = ok(WarnRegex),
        Processor = processor(LogRegex, ErrorRegex, WarnRegex)
    ;
        error(&quot;Failed to compile regexes&quot;)
    ).</code></pre>
<h3 id="use-specific-patterns">2. Use Specific Patterns</h3>
<pre class="mercury"><code>% Good: Specific pattern
good_pattern = &quot;\\b[A-Z]{2}\\d{6}\\b&quot;.  % Matches specific ID format

% Bad: Too general
bad_pattern = &quot;.*&quot;.  % Matches everything, inefficient</code></pre>
<h3 id="use-anchors-when-possible">3. Use Anchors When Possible</h3>
<pre class="mercury"><code>% Good: Anchored pattern
regex.match(&quot;^ERROR:&quot;, LogLine, _).  % Only checks beginning

% Less efficient: Unanchored
regex.search(&quot;ERROR:&quot;, LogLine, _).  % Searches entire string</code></pre>
<h3 id="avoid-backtracking">4. Avoid Backtracking</h3>
<pre class="mercury"><code>% Good: Possessive quantifiers
efficient_pattern = &quot;\\d++\\.\\d++&quot;.  % No backtracking

% Bad: Greedy with potential backtracking
inefficient_pattern = &quot;\\d+\\.\\d+&quot;.</code></pre>
<h2 id="complete-examples">Complete Examples</h2>
<h3 id="example-1-log-file-analyzer">Example 1: Log File Analyzer</h3>
<pre class="mercury"><code>:- module log_analyzer.
:- interface.
:- import_module io.
:- pred main(io::di, io::uo) is det.

:- implementation.
:- import_module regex, string, list, maybe, int, map.

:- type log_level
    ---&gt;    error
    ;       warning
    ;       info
    ;       debug.

:- type log_entry
    ---&gt;    log_entry(
                timestamp :: string,
                level     :: log_level,
                message   :: string
            ).

main(!IO) :-
    % Compile regex patterns
    LogPattern = &quot;\\[(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2})\\] &quot; ++
                 &quot;(ERROR|WARNING|INFO|DEBUG): (.+)&quot;,
    
    regex.compile(LogPattern, CompileResult),
    (
        CompileResult = ok(LogRegex),
        
        % Initialize counters
        map.init(Counters0),
        map.set(error, 0, Counters0, Counters1),
        map.set(warning, 0, Counters1, Counters2),
        map.set(info, 0, Counters2, Counters3),
        map.set(debug, 0, Counters3, Counters),
        
        % Process log file
        io.open_input(&quot;application.log&quot;, OpenResult, !IO),
        (
            OpenResult = ok(Stream),
            process_log_stream(Stream, LogRegex, Counters, FinalCounters, !IO),
            io.close_input(Stream, !IO),
            
            % Print summary
            print_summary(FinalCounters, !IO)
        ;
            OpenResult = error(Error),
            io.format(&quot;Error opening log file: %s\n&quot;, 
                     [s(io.error_message(Error))], !IO)
        )
    ;
        CompileResult = error(compile_error(Msg)),
        io.format(&quot;Regex compilation failed: %s\n&quot;, [s(Msg)], !IO)
    ).

:- pred process_log_stream(io.text_input_stream::in, regex::in,
                          map(log_level, int)::in, map(log_level, int)::out,
                          io::di, io::uo) is det.
process_log_stream(Stream, LogRegex, !Counters, !IO) :-
    io.read_line_as_string(Stream, Result, !IO),
    (
        Result = ok(Line),
        process_log_line(Line, LogRegex, !Counters, !IO),
        process_log_stream(Stream, LogRegex, !Counters, !IO)
    ;
        Result = eof
    ;
        Result = error(_)
    ).

:- pred process_log_line(string::in, regex::in,
                        map(log_level, int)::in, map(log_level, int)::out,
                        io::di, io::uo) is det.
process_log_line(Line, LogRegex, !Counters, !IO) :-
    regex.search_compiled(LogRegex, Line, MatchResult),
    (
        MatchResult = yes(Match),
        regex.group(Match, 1, yes(Timestamp)),
        regex.group(Match, 2, yes(LevelStr)),
        regex.group(Match, 3, yes(Message)),
        
        ( parse_level(LevelStr, Level) -&gt;
            % Update counter
            map.lookup(!.Counters, Level, OldCount),
            map.set(Level, OldCount + 1, !Counters),
            
            % Process based on level
            ( Level = error -&gt;
                io.format(&quot;ERROR at %s: %s\n&quot;, 
                         [s(Timestamp), s(Message)], !IO)
            ; Level = warning -&gt;
                % Could send warnings to a different handler
                true
            ;
                % INFO and DEBUG - usually just count
                true
            )
        ;
            io.format(&quot;Unknown log level: %s\n&quot;, [s(LevelStr)], !IO)
        )
    ;
        MatchResult = no
        % Not a valid log line, skip
    ).

:- pred parse_level(string::in, log_level::out) is semidet.
parse_level(&quot;ERROR&quot;, error).
parse_level(&quot;WARNING&quot;, warning).
parse_level(&quot;INFO&quot;, info).
parse_level(&quot;DEBUG&quot;, debug).

:- pred print_summary(map(log_level, int)::in, io::di, io::uo) is det.
print_summary(Counters, !IO) :-
    io.write_string(&quot;\nLog Summary:\n&quot;, !IO),
    io.write_string(&quot;============\n&quot;, !IO),
    map.lookup(Counters, error, Errors),
    map.lookup(Counters, warning, Warnings),
    map.lookup(Counters, info, Infos),
    map.lookup(Counters, debug, Debugs),
    io.format(&quot;Errors:   %d\n&quot;, [i(Errors)], !IO),
    io.format(&quot;Warnings: %d\n&quot;, [i(Warnings)], !IO),
    io.format(&quot;Info:     %d\n&quot;, [i(Infos)], !IO),
    io.format(&quot;Debug:    %d\n&quot;, [i(Debugs)], !IO),
    Total = Errors + Warnings + Infos + Debugs,
    io.format(&quot;Total:    %d\n&quot;, [i(Total)], !IO).</code></pre>
<h3 id="example-2-configuration-file-parser">Example 2: Configuration
File Parser</h3>
<pre class="mercury"><code>:- module config_parser.
:- interface.
:- import_module io, map.

:- type config == map(string, string).

:- pred parse_config_file(string::in, maybe_error(config)::out, 
                         io::di, io::uo) is det.

:- implementation.
:- import_module regex, string, list, maybe.

parse_config_file(Filename, Result, !IO) :-
    io.open_input(Filename, OpenResult, !IO),
    (
        OpenResult = ok(Stream),
        parse_config_stream(Stream, map.init, Config, !IO),
        io.close_input(Stream, !IO),
        Result = ok(Config)
    ;
        OpenResult = error(Error),
        Result = error(io.error_message(Error))
    ).

:- pred parse_config_stream(io.text_input_stream::in, config::in, config::out,
                           io::di, io::uo) is det.
parse_config_stream(Stream, !Config, !IO) :-
    io.read_line_as_string(Stream, ReadResult, !IO),
    (
        ReadResult = ok(Line),
        process_config_line(Line, !Config),
        parse_config_stream(Stream, !Config, !IO)
    ;
        ReadResult = eof
    ;
        ReadResult = error(_)
    ).

:- pred process_config_line(string::in, config::in, config::out) is det.
process_config_line(Line, !Config) :-
    % Remove comments and trim
    CommentPattern = &quot;#.*$&quot;,
    regex.sub(CommentPattern, &quot;&quot;, Line, NoComment),
    Trimmed = string.strip(NoComment),
    
    % Parse key=value pairs
    ( Trimmed = &quot;&quot; -&gt;
        % Empty line, skip
        true
    ;
        KeyValuePattern = &quot;^([\\w\\.]+)\\s*=\\s*(.*)$&quot;,
        regex.search(KeyValuePattern, Trimmed, MatchResult),
        (
            MatchResult = yes(Match),
            regex.group(Match, 1, yes(Key)),
            regex.group(Match, 2, yes(RawValue)),
            
            % Process value (remove quotes if present)
            process_value(RawValue, Value),
            map.set(Key, Value, !Config)
        ;
            MatchResult = no
            % Invalid line format, skip
        )
    ).

:- pred process_value(string::in, string::out) is det.
process_value(RawValue, Value) :-
    % Remove surrounding quotes
    QuotePattern = &quot;^[\&quot;&#39;](.*)[&#39;|\&quot;]$&quot;,
    ( regex.search(QuotePattern, RawValue, yes(Match)) -&gt;
        regex.group(Match, 1, yes(Value))
    ;
        Value = RawValue
    ).</code></pre>
<h3 id="example-3-data-validator">Example 3: Data Validator</h3>
<pre class="mercury"><code>:- module data_validator.
:- interface.
:- import_module io, list, maybe.

:- type validation_error
    ---&gt;    invalid_email(string)
    ;       invalid_phone(string)
    ;       invalid_date(string)
    ;       invalid_ssn(string).

:- pred validate_user_data(string::in, string::in, string::in, string::in,
                          list(validation_error)::out) is det.

:- implementation.
:- import_module regex, string.

validate_user_data(Email, Phone, Date, SSN, Errors) :-
    validate_email(Email, EmailErrors),
    validate_phone(Phone, PhoneErrors),
    validate_date(Date, DateErrors),
    validate_ssn(SSN, SSNErrors),
    list.append_list([EmailErrors, PhoneErrors, DateErrors, SSNErrors], Errors).

:- pred validate_email(string::in, list(validation_error)::out) is det.
validate_email(Email, Errors) :-
    EmailPattern = &quot;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$&quot;,
    ( regex.fullmatch(EmailPattern, Email, yes(_)) -&gt;
        Errors = []
    ;
        Errors = [invalid_email(Email)]
    ).

:- pred validate_phone(string::in, list(validation_error)::out) is det.
validate_phone(Phone, Errors) :-
    % US phone number: (123) 456-7890 or 123-456-7890 or 1234567890
    PhonePattern = &quot;^\\(?([0-9]{3})\\)?[-. ]?([0-9]{3})[-. ]?([0-9]{4})$&quot;,
    ( regex.fullmatch(PhonePattern, Phone, yes(_)) -&gt;
        Errors = []
    ;
        Errors = [invalid_phone(Phone)]
    ).

:- pred validate_date(string::in, list(validation_error)::out) is det.
validate_date(Date, Errors) :-
    % ISO format: YYYY-MM-DD
    DatePattern = &quot;^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$&quot;,
    ( regex.fullmatch(DatePattern, Date, yes(Match)) -&gt;
        regex.group(Match, 1, yes(YearStr)),
        regex.group(Match, 2, yes(MonthStr)),
        regex.group(Match, 3, yes(DayStr)),
        
        % Additional validation could check for valid dates
        % (e.g., no Feb 30th)
        Errors = []
    ;
        Errors = [invalid_date(Date)]
    ).

:- pred validate_ssn(string::in, list(validation_error)::out) is det.
validate_ssn(SSN, Errors) :-
    % US SSN: 123-45-6789
    SSNPattern = &quot;^(?!000|666)[0-9]{3}-(?!00)[0-9]{2}-(?!0000)[0-9]{4}$&quot;,
    ( regex.fullmatch(SSNPattern, SSN, yes(_)) -&gt;
        Errors = []
    ;
        Errors = [invalid_ssn(SSN)]
    ).</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="common-issues">Common Issues</h3>
<ol type="1">
<li><strong>Pattern Not Matching</strong>
<ul>
<li>Check Mercury string escaping (double backslashes)</li>
<li>Test pattern with online regex testers</li>
<li>Use <code>verbose</code> flag for complex patterns</li>
</ul></li>
<li><strong>Compilation Errors</strong>
<ul>
<li>Unmatched brackets or parentheses</li>
<li>Invalid escape sequences</li>
<li>Use <code>escape/2</code> for literal strings</li>
</ul></li>
<li><strong>Performance Issues</strong>
<ul>
<li>Compile patterns once and reuse</li>
<li>Avoid catastrophic backtracking</li>
<li>Use more specific patterns</li>
</ul></li>
<li><strong>Memory Issues</strong>
<ul>
<li>PCRE2 manages its own memory</li>
<li>Match objects are garbage collected</li>
<li>Consider streaming for large files</li>
</ul></li>
</ol>
<h2 id="quick-reference">Quick Reference</h2>
<h3 id="basic-operations">Basic Operations</h3>
<pre class="mercury"><code>regex.search(Pattern, Text, Result)           % Find first
regex.match(Pattern, Text, Result)            % Match at start
regex.fullmatch(Pattern, Text, Result)        % Match entire string
regex.findall(Pattern, Text, Matches)         % Find all strings
regex.finditer(Pattern, Text, MatchObjects)   % Find all matches
regex.sub(Pattern, Replacement, Text, Result) % Replace all
regex.split(Pattern, Text, Parts)             % Split string
regex.escape(Text, SafePattern)               % Escape special chars</code></pre>
<h3 id="match-object-access">Match Object Access</h3>
<pre class="mercury"><code>regex.group(Match, N, Group)                  % Get group N
regex.groups(Match, AllGroups)                % Get all groups
regex.group_by_name(Match, Name, Group)       % Get named group
regex.named_group_names(Match, Names)         % Get group names
regex.span(Match, N, {Start, End})           % Get positions</code></pre>
<h3 id="compilation">Compilation</h3>
<pre class="mercury"><code>regex.compile(Pattern, Flags, Result)         % Compile with flags
regex.search_compiled(Regex, Text, Result)    % Use compiled regex</code></pre>
<h2 id="additional-resources">Additional Resources</h2>
<ul>
<li><a href="https://www.pcre.org/current/doc/html/">PCRE2
Documentation</a></li>
<li><a href="https://docs.python.org/3/library/re.html">Python re
Module</a> (similar API)</li>
<li><a href="https://www.regular-expressions.info/">Regular Expression
Reference</a></li>
<li>Mercury Language Reference Manual</li>
</ul>
<h2 id="contributing">Contributing</h2>
<p>To contribute to mercury-re: 1. Fork the repository 2. Create a
feature branch 3. Add tests for new functionality 4. Ensure all tests
pass 5. Submit a pull request</p>
<h2 id="license">License</h2>
<p>See LICENSE file in the mercury-re repository.</p>
